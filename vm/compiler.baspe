$Console:Only
DefLng A-Z

Const ARG_TYPE_REGISTER = 1
Const ARG_TYPE_MEMORY = 2
Const ARG_TYPE_VALUE = 3

Dim Shared FileBuffer As String, FileBufferOffset As _Unsigned Long
If _FileExists(Command$) Then FileBuffer = _ReadFile$(Command$) Else If _FileExists(_StartDir$ + "/" + Command$) Then FileBuffer = _ReadFile$(_StartDir$ + "/" + Command$) Else System
FileBufferOffset = 0
Dim Shared OutputFile$, OutputFileOffset As _Unsigned Long: OutputFile$ = ""
Dim Shared Registers$, LabelsList$, LabelsOffset$, PendingLabelsList$, CurrentLine As _Unsigned Integer
Registers$ = ListStringFromString("a,b,c,d,e,f,i,s")
LabelsList$ = ListStringNew
LabelsOffset$ = ListStringNew
PendingLabelsList$ = ListStringNew
Do While FileBufferOffset < Len(FileBuffer)
    OriginalLine$ = GetNextLine$: CurrentLine = CurrentLine + 1
    Print "Current Line: "; ListStringPrint(SplitStringIntoList$(OriginalLine$))
    L$ = LCase$(OriginalLine$)
    If InStr(L$, ":") Then
        ListStringAdd LabelsList$, ListStringGet(SplitStringIntoList$(L$), 1)
        ListStringAdd LabelsOffset$, MKI$(OutputFileOffset)
        Print "    Adding Label: "; ListStringGet(LabelsList$, ListStringLength(LabelsList$)); ":"; OutputFileOffset
        _Continue
    End If
    If InStr(L$, ";") Then L$ = SplitStringIntoList$(_Trim$(Left$(L$, InStr(L$, ";")))) Else L$ = SplitStringIntoList$(L$) ' Remove Comments
    FIRST_WORD$ = ListStringGet(L$, 1)
    If ListStringLength(L$) >= 2 Then ARG_ONE$ = ListStringGet(L$, 2)
    If ListStringLength(L$) >= 3 Then ARG_TWO$ = ListStringGet(L$, 3)
    Select Case FIRST_WORD$
        Case "data": L$ = SplitStringIntoList$(OriginalLine$): For I = 2 To ListStringLength(L$)
                __I$ = ListStringGet(L$, I)
                If Asc(__I$, 1) = 34 Then
                    For __I = 2 To Len(__I$) - 1
                        AddBitBuffer Asc(__I$, __I), 8
                    Next __I
                Else
                    AddBitBuffer Val(__I$), 8
                End If
            Next I
        Case "nop": AddBitBuffer 0, 8
        Case "clc", "stc", "hlt", "ret": AddBitBuffer 18 + ListStringSearch(ListStringFromString("clc,stc,hlt,ret"), FIRST_WORD$), 8
        Case "lodb", "lodw", "stob", "stow": AddBitBuffer 44 + ListStringSearch(ListStringFromString("lodb,lodw,stob,stow"), FIRST_WORD$), 8
        Case "not": AddBitBuffer 11, 8: AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 8
        Case "int": AddBitBuffer 43, 8: AddBitBuffer ParseValue(ARG_ONE$), 8
        Case "push", "pop": AddBitBuffer 22 + ListStringSearch(ListStringFromString("push,pop"), FIRST_WORD$), 8
            AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 8
        Case "call", "jc", "jnc", "jz", "jnz": AddBitBuffer 24 + ListStringSearch(ListStringFromString("call,jc,jnc,jz,jnz"), FIRST_WORD$), 8
            AddBitBuffer ParseMemoryLocation(ARG_ONE$), 16
        Case "jmp": If GetArgType(ARG_ONE$) = ARG_TYPE_MEMORY Then
                AddBitBuffer 44, 8
                AddBitBuffer ParseMemoryLocation(ARG_ONE$), 16
            Else
                AddBitBuffer 29 + ListStringSearch(ListStringFromString("eq,l,g,le,ge,ne"), ARG_ONE$), 8
                AddBitBuffer ParseMemoryLocation(ARG_TWO$), 16
            End If
        Case "mov": Select Case GetArgType(ARG_TWO$)
                Case ARG_TYPE_REGISTER: Select Case GetArgType(ARG_ONE$)
                        Case ARG_TYPE_REGISTER: AddBitBuffer 36, 8: AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 4: AddBitBuffer ListStringSearch(Registers$, ARG_TWO$), 4
                        Case ARG_TYPE_MEMORY: AddBitBuffer 39, 8: AddBitBuffer ListStringSearch(Registers$, ARG_TWO$), 8: AddBitBuffer ParseMemoryLocation(ARG_ONE$), 16
                    End Select
                Case ARG_TYPE_MEMORY: AddBitBuffer 37, 8: AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 8: AddBitBuffer ParseMemoryLocation(ARG_TWO$), 16
                Case ARG_TYPE_VALUE: AddBitBuffer 38, 8: AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 8: AddBitBuffer ChangeEndianInteger(ParseValue(ARG_TWO$)), 16
            End Select
        Case "add", "mul", "div", "shl", "shr", "test", "and", "or", "xor", "cmp": Select Case GetArgType(ARG_TWO$)
                Case ARG_TYPE_REGISTER: AddBitBuffer Val(ListStringGet(ListStringFromString("1,3,5,7,9,12,13,15,17,40"), ListStringSearch(ListStringFromString("add,mul,div,shl,shr,test,and,or,xor,cmp"), FIRST_WORD$))), 8
                    AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 4: AddBitBuffer ListStringSearch(Registers$, ARG_TWO$), 4
                Case ARG_TYPE_MEMORY: AddBitBuffer _IIf(FIRST_WORD$ = "cmp", 41, InvalidInstructionError), 8
                    AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 8: AddBitBuffer ParseMemoryLocation(ARG_TWO$), 16
                Case ARG_TYPE_VALUE: AddBitBuffer Val(ListStringGet(ListStringFromString("2,4,6,8,10,14,16,18,42"), ListStringSearch(ListStringFromString("add,mul,div,shl,shr,and,or,xor,cmp"), FIRST_WORD$))), 8
                    If ListStringSearch(ListStringFromString("shl,shr"), FIRST_WORD$) Then
                        AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 4: AddBitBuffer ParseValue(ARG_TWO$), 4
                    Else
                        AddBitBuffer ListStringSearch(Registers$, ARG_ONE$), 8: AddBitBuffer ChangeEndianInteger(ParseValue(ARG_TWO$)), 16
                    End If
            End Select
    End Select
Loop
Print
Print "Labels: "; ListStringPrint(LabelsList$)
Print "Processing Pending Labels: "; ListStringLength(PendingLabelsList$)
For I = 1 To ListStringLength(PendingLabelsList$)
    L$ = ListStringGet(PendingLabelsList$, I)
    __Label$ = Left$(L$, Len(L$) - 2)
    If ListStringSearch(LabelsList$, __Label$) = 0 Then System InvalidLabel(__Label$)
    __Position~% = CVI(Right$(L$, 2))
    Print "    Updating "; __Label$; " at position:"; __Position~%
    Mid$(OutputFile$, __Position~%, 2) = ListStringGet(LabelsOffset$, ListStringSearch(LabelsList$, __Label$))
Next I
_WriteFile Command$ + ".bin", Left$(OutputFile$, OutputFileOffset)
System

Function GetArgType~%% (ARG$) Static
    Select Case Asc(ARG$, 1)
        Case 97 To 102, 105, 115: GetArgType~%% = ARG_TYPE_REGISTER
        Case 48 To 57: GetArgType~%% = ARG_TYPE_VALUE
        Case 91: GetArgType~%% = ARG_TYPE_MEMORY
        Case Else: GetArgType~%% = ARG_TYPE_MEMORY
    End Select
End Function

Sub AddBitBuffer (Value~&&, Bits~%%)
    Static BitBuffer~&&, BitBufferSize~%%, BitCount~%%
    B$ = _Bin$(Value~&&): Print "    Adding: "; String$(Bits~%% - Len(B$), 48) + B$
    BitBuffer~&& = _ShL(BitBuffer~&&, Bits~%%) Or Value~&&
    BitBufferSize~%% = BitBufferSize~%% + Bits~%%
    PutBitBuffer OutputFile$, OutputFileOffset, BitBuffer~&&, BitBufferSize~%%, BitCount~%%
End Sub
Function IsValue` (I$) Static
    Select Case Asc(I$)
        Case 48 To 57: IsValue = -1
        Case Else: IsValue = 0
    End Select
End Function
Function ParseValue~% (I$) Static
    If Left$(I$, 2) = "0x" Then
        ParseValue~% = Val("&H" + Mid$(I$, 3))
    ElseIf Right$(I$, 1) = "h" Then
        ParseValue~% = Val("&H" + Left$(I$, Len(I$) - 1))
    ElseIf Right$(I$, 1) = "b" Then
        ParseValue~% = Val("&B" + Left$(I$, Len(I$) - 1))
    Else
        ParseValue~% = Val(I$)
    End If
End Function
Function ParseMemoryLocation~% (ARG$) Static
    If Asc(ARG$, 1) = 91 Then
        ParseMemoryLocation~% = ParseValue~%(Mid$(ARG$, 2, Len(ARG$) - 2))
    Else
        Print "    Adding Pending Label: "; ARG$; " for "; _ToStr$(OutputFileOffset + 1)
        ListStringAdd PendingLabelsList$, ARG$ + MKI$(OutputFileOffset + 1)
        ParseMemoryLocation~% = 0
    End If
End Function

Function ChangeEndianInteger~% (__T~%) Static
    ChangeEndianInteger~% = (_ShL(__T~%, 8) Or _ShR(__T~%, 8)) And 65535
End Function

Function InvalidInstruction Static
    Print "    Invalid Instruction at Line: "; CurrentLine
    InvalidInstruction = 1
    System 1
End Function
Function InvalidLabel (L$) Static
    Print "    Invalid Label: "; L$
    InvalidLabel = 2
End Function

$Checking:Off
'$Include:'include\putbitbuffermsb.bm'
'$Include:'include\dsa\liststring.bas'
Function SplitStringIntoList$ (I$) Static
    O$ = ListStringNew
    ListStringAdd O$, Left$(I$, 1)
    For I = 2 To Len(I$)
        B~%% = Asc(I$, I)
        Select Case B~%%
            Case 32, 44: If Len(ListStringGet(O$, ListStringLength(O$))) Then ListStringAdd O$, ""
            Case 34: If ListStringGet(O$, ListStringLength(O$)) = "" Then ListStringDelete O$, ListStringLength(O$)
                ListStringAdd O$, Mid$(I$, I, InStr(I + 1, I$, Chr$(34)) - I + 1): I = InStr(I + 1, I$, Chr$(34)) + 1
            Case 91, 93, 95, 65 To 90, 48 To 57, 97 To 122: ListStringEdit O$, ListStringGet$(O$, ListStringLength(O$)) + Chr$(B~%%), ListStringLength(O$)
        End Select
    Next I
    SplitStringIntoList$ = O$
End Function
Function GetNextLine$ () Static ' Ultra Fast File Reader
    __I~& = InStr(FileBufferOffset, FileBuffer, Chr$(10))
    If __I~& Then
        GetNextLine$ = Mid$(FileBuffer, FileBufferOffset, __I~& - FileBufferOffset)
        FileBufferOffset = __I~& + 1
    Else
        GetNextLine$ = Mid$(FileBuffer, FileBufferOffset)
        FileBufferOffset = Len(FileBuffer)
    End If
End Function
$Checking:On
